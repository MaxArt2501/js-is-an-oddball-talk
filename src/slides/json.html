<p-slide>
  <h3 class="center"><span class="JavaScript"></span> <p-fragment>Object Notation</p-fragment></h3>
  <p-fragment class="self-center center">
    <h1>‚ù§Ô∏è</h1>
    <h3 class="JavaScript"></h3>
  </p-fragment>
  <p-fragment class="big-x" style="width: 8em; top: 28%; left: calc(50% - 4em)"></p-fragment>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js input">JSON.stringify({
  void: undefined,
  func() {},
  fn: () => {},
  symbol: Symbol(),
  [Symbol('foo')]: 'symbol'
})</code>
<p-fragment><code class="language-js output">'{}' // üôÑ</code></p-fragment></pre>
</p-slide>
<p-slide>
  <pre
    class="big self-center"
  ><p-fragment class="the-stroke" aria-label="A strike through the JSON.parse+stringify code" style="width: 46ch"></p-fragment><code class="language-js">const copy = JSON.parse(JSON.stringify(item));</code></pre>
  <p-fragment class="self-center">
    <pre class="big"><code class="language-js">const copy = structuredClone(item);</code></pre>
  </p-fragment>
  <p-fragment class="self-center">
    <span class="browser chrome">98</span>
    <span class="browser firefox">94</span>
    <span class="browser safari">15.4</span>
  </p-fragment>
  <p-notes>It is better, as it preserves undefined, although it doesn't copy symbol properties, and throws if it meets function or symbol values</p-notes>
</p-slide>
<p-slide class="row justify-evenly align-center">
  <pre class="big"><code class="language-js">structuredClone(item);</code></pre>
  <p-fragment wtf-level="8"></p-fragment>
  <p-notes>I'd say 9, but <code>structuredClone</code> is actually <em>slower!</em></p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">{ "bigMcHuge": 12345678901234567890 }</code></pre>
  <p-notes>
    Point is, JSONs can have arbitrarily large numbers. It's an interchange format, so it doesn't care about language limitations, not even JavaScript's. But JavaScript has
    arbitrarily large integers now, doesn't it? They're the BigInts.
  </p-notes>
  <pre class="big self-center language-js"><p-fragment><code class="language-js">const bigMcHuge = 12345678901234567890n;</code></p-fragment>

<p-fragment><code class="language-js input">JSON.stringify({ bigMcHuge })</code></p-fragment>
<p-fragment><code class="language-error output">Uncaught TypeError: Do not know how to
  serialize a BigInt</code></p-fragment></pre>
  <p-notes>Haha, of course you know how to serialize a BigInt, you silly goose! Don't BigInts have the <code>toString</code> method?</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">BigInt.prototype.toJSON = function() {
  return this.toString();
};</code></pre>
  <p-fragment>
    <h1 class="center">üò±</h1>
  </p-fragment>
</p-slide>
<p-slide>
  <pre class="big self-center">

  <code class="language-js">  array.flatten()</code><p-fragment class="big-x" style="width: 4em; left: 21%; top: 11%"></p-fragment><p-fragment>  &#x27f6;  <code class="language-js">array.flat()</code></p-fragment>

  <p-fragment><code class="language-js">array.contains(x)</code></p-fragment><p-fragment class="big-x" style="width: 4em; left: 18%; top: 38%"></p-fragment><p-fragment>  &#x27f6;  <code class="language-js">array.includes(x)</code></p-fragment>

  <p-fragment><code class="language-js">array.groupBy(fn)</code></p-fragment><p-fragment class="big-x" style="width: 4em; left: 18%; top: 63%"></p-fragment><p-fragment>  &#x27f6;  <code class="language-js">Object.groupBy(array, fn)</code></p-fragment>

</pre>
</p-slide>
<p-slide>
  <blockquote>&hellip; one of the few cases where patching built-in objects is not explicitly discouraged</blockquote>
  <cite>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#use_within_json">MDN</a>
  </cite>
</p-slide>
<p-slide class="row justify-evenly align-center">
  <pre class="big"><code class="language-js">BigInt.prototype.toJSON = ...</code></pre>
  <p-fragment wtf-level="8"></p-fragment>
</p-slide>
<p-slide>
  <p-fragment index="1" style="position: absolute; top: 10%; left: 40%">
    <span class="browser chrome">85</span>
    <span class="browser firefox">79</span>
    <span class="browser safari">14</span>
    <div class="the-arrow" style="top: 75%; left: 33%; width: 0.8em; rotate: 10deg"></div>
  </p-fragment>
  <pre
    class="big self-center"
  ><code class="language-js">BigInt.prototype.toJSON </code><p-fragment class="collapsed"><code class="language-js">??</code></p-fragment>= <code class="language-js">function() {
  return this.toString();
};</code>

<p-fragment index="1"><code class="language-js input">JSON.stringify({ bigMcHuge })</code></p-fragment>
<p-fragment index="1"><code class="language-js output">'{"bigMcHuge":"12345678901234567890"}'</code></p-fragment></pre>
  <p-fragment index="1"
    ><img src="img/pointer.webp" alt="A pointing hand to the opening quotes of the number" class="pointing-start" /><img
      src="img/pointer.webp"
      alt="A pointing hand to the closing quotes of the number"
      class="pointing-end"
  /></p-fragment>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">BigInt.prototype.toJSON ??= function() {</code>
  <p-fragment><code class="language-js">return JSON.rawJSON(this.toString());</code></p-fragment><p-fragment
  class="highlight" aria-label="A highlighting around the JSON.rawJSON function name" style="top: 1lh; left: 9ch; width: 12ch"></p-fragment>
<code class="language-js">};</code>

<p-fragment><code class="language-js input">JSON.stringify({ bigMcHuge })</code></p-fragment>
<p-fragment><code class="language-js output">'{"bigMcHuge":12345678901234567890}'</code></p-fragment></pre>
  <p-fragment style="position: absolute; top: 50%; left: 80%; font-size: 200%">üéâ</p-fragment>
  <p-fragment class="self-center">
    <span class="browser chrome">114</span>
    <span class="browser firefox">135</span>
    <span class="browser safari">-</span>
  </p-fragment>
  <p-notes>
    What does <code>JSON.rawJSON</code> return? A frozen object with no prototype, and a single constant string property named <code>rawJSON</code>, whose value is the function
    argument and must be a formally correct JSON <i>primitive</i> value. It cannot even be converted to a string, but has an internal flag that allows us to use it with
    <code>JSON.stringify</code> alone.
  </p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">const raw = '{ "bigMcHuge": 12345678901234567890 }';</code>

<p-fragment><code class="language-js input">JSON.parse(raw)</code></p-fragment>
<p-fragment><code class="language-js output">{ bigMcHuge: 12345678901234567000 }</code></p-fragment><p-fragment
class="highlight" style="top: 3lh; left: 32ch; width: 3ch; color: red"></p-fragment><p-fragment
class="highlight" style="top: 0; left: 45ch; width: 3ch; color: red"></p-fragment></pre>
  <p-notes>Some may say: "I know! I'll use a reviver!" - Except, no you don't.</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">JSON.parse(raw, (key, value) => {</code>
  <p-fragment><code class="language-js">// value already lost precision :(</code></p-fragment>
<code class="language-js">});</code></pre>
</p-slide>
<p-slide>
  <pre
    class="big self-center"
  ><code class="language-js">JSON.parse(raw, (key, value</code><p-fragment class="collapsed"><code class="language-js">, context</code></p-fragment><code class="language-js">) => {   </code>
  <p-fragment index="1"><code class="language-js">return BigInt(context.source);</code></p-fragment>
<code class="language-js">});</code></pre>
  <p-fragment>
    <pre class="big" style="position: absolute; top: 10%; left: 30%"><code class="language-js">{ source: '12345678901234567890' }</code></pre>
    <div class="the-arrow" style="top: 24%; left: 63%; scale: -1 1; width: 1.2em"></div>
  </p-fragment>
  <p-fragment class="self-center" style="position: absolute; bottom: 25%" index="1">
    <span class="browser chrome">114</span>
    <span class="browser firefox">135</span>
    <span class="browser safari">-</span>
  </p-fragment>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">JSON.parse(raw, (key, value, context) => {</code>
  <p-fragment><code class="language-js">if (!/\D/.test(context.source))</code></p-fragment>
    <code class="language-js">return BigInt(context.source);</code>
  <p-fragment><code class="language-js">return value;</code></p-fragment>
});</pre>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">JSON.parse(raw, (key, value, { source }) => {
  return isBigInt(source) ? BigInt(source) : value;
});</code><p-fragment class="highlight" aria-label="A marker circle around 'isBigInt' function name"
  style="top: 1lh;width: 8ch;left: 9ch"></p-fragment>

<p-fragment><code class="language-js">const isBigInt = numstr => !/\D/.test(numstr) &&</code></p-fragment>
  <p-fragment><code class="language-js">numstr.localeCompare(
    '9007199254740991', undefined, { numeric: true }
  ) > 0;</code></p-fragment></pre>
  <p-notes> There must be something that tells us when a numeric string is greater than anothe&hellip; Golly, it's our good friend <code>localeCompare</code>! </p-notes>
</p-slide>
<!-- <p-slide>
  <pre class="big self-center"><code class="language-js">const numCompare = new Intl.Collator(
    undefined, { numeric: true }).compare;

const isBigInt = numstr => !/\D/.test(numstr) &&
  numCompare(numstr, '9007199254740991') > 0;</code></pre>
</p-slide> -->
