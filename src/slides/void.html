<p-slide class="center">
  <h3>Have you seen this ðŸ¦„?</h3>
  <p-fragment>
    <h3><code>void</code></h3>
  </p-fragment>
  <p-fragment><br />(Not to be confused with <span class="TypeScript">TypeScript</span>'s <code>void</code>)</p-fragment>
</p-slide>
<p-slide>
  <h4 class="center">&ldquo;The <code>void</code> operator evaluates the given expression and then returns <code>undefined</code>.&rdquo;</h4>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-html">&lt;a href="javascript:void(0)">Click me!&lt;/a></code></pre>
  <p-fragment class="big-x" style="width: 6em; left: 34%; top: 25%"></p-fragment>
  <p-fragment class="self-center">
    <pre class="big"><code class="language-html">&lt;a href="javascript:;">Click me!&lt;/a></code></pre>
  </p-fragment>
  <p-notes>Don't do this either: use a button!</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><p-fragment class="collapsed"><code class="language-js">void</code></p-fragment> <code class="language-js">function() { /* ... */ }();</code></pre>
  <p-fragment class="big-x" style="width: 6em; left: 37%; top: 15%"></p-fragment>
  <p-fragment class="self-center">
    <pre class="big"><code class="language-js">(function() { /* ... */ })();</code></pre>
  </p-fragment>
  <p-fragment class="self-center">
    <pre class="big"><code class="language-js">(() => { /* ... */ })();</code></pre>
  </p-fragment>
</p-slide>
<p-slide>
  <pre
    class="big self-center"
  ><code class="language-html">&lt;button onclick="</code><p-fragment class="collapsed" index="1"><code class="language-js">void </code></p-fragment><code class="language-html">doSomething()">
  Click me!
&lt;/button></code></pre>

  <p-fragment index="0" class="self-center">
    <pre class="big"><code class="language-js">function doSomething() {
  ...
  return false;
}</code></pre>
  </p-fragment>
  <p-notes>Don't use legacy event registration</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">useEffect(doSomething);</code></pre>
  <p-fragment class="self-center">
    <pre class="big"><code class="language-js">export const doSomething = () => {
  ...
  return abortFn;
};</code></pre>
  </p-fragment>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">useEffect(doSomething);</code></pre>
  <p-fragment class="big-x" style="width: 6em; left: 46%; top: 7%"></p-fragment>
  <p-fragment class="self-center">
    <pre
      class="big"
    ><code class="language-js">useEffect(() => </code><p-fragment class="collapsed" index="1"><code class="language-js">void </code></p-fragment><code class="language-js">doSomething());</code></pre>
  </p-fragment>
  <p-fragment class="self-center">
    <pre class="big"><code class="language-js">useEffect(() => {
  return doSomething();
});</code></pre>
  </p-fragment>
  <p-fragment class="big-x" style="width: 6em; left: 37%; top: 52%"></p-fragment>
  <p-notes>
    <p>
      "I can just wrap it in curly braces!" - yes, but code formatters may have a different opinion, and you might just miss the change when they run. So here's a practical use
      case for <code>void</code>
    </p>
    <p>I also think it's nice how it communicates that you want to discard the return value of the function, although some might get confused by this strange keyword</p>
  </p-notes>
</p-slide>
<p-slide>
  <h3 class="center">
    <code
      >@typescript-eslint/<br />
      no-floating-promises</code
    >
  </h3>
  <p-fragment class="self-center">
    <pre class="big"><code class="language-js">useEffect(() => {</code>
  <p-fragment class="collapsed"><code class="language-js">void </code></p-fragment><code class="language-js">doSomethingAsync();
});</code></pre>
  </p-fragment>
</p-slide>
