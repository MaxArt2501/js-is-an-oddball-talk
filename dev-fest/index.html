<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript is an oddball</title>
    <base href=".." />
    <link rel="shortcut icon" href="favicon.svg" type="image/svg+xml" />
    <link rel="stylesheet" href="vendor/prismjs/themes/prism.css" />
    <link rel="stylesheet" href="vendor/prismjs/themes/prism-okaidia.css" />
    <link rel="stylesheet" href="css/main.css" />
    <link rel="stylesheet" href="css/print.css" media="print" />
    <link rel="stylesheet" href="css/presentation.css" />
  </head>

  <body>
    <p-deck>
      <!--slide:cover-devfest--><p-slide>
  <h3>JavaScript&hellip;</h3>
  <p-fragment class="self-center">
    <img src="img/js.svg" class="bojs-oddball" alt="JS logo" />
  </p-fragment>
  <p-fragment class="self-end">
    <h3>&hellip; is an oddball</h3>
  </p-fragment>
</p-slide>
<p-slide class="justify-start">
  <gfy-blob
    clearcoatroughness="0.4"
    clearcoat="0.23"
    clearcolor="#141411"
    color="#2a0b29"
    envmap="img/envmap.jpg"
    envmapintensity="0.95"
    fixnormals=""
    frequency="0.01"
    metalness="0.64"
    numberofwaves="1.47"
    reflectivity="1"
    roughness="0"
    surfacepoleamount="1"
    surfacedistort="3.2"
    surfacefrequency="0.97"
    surfacespeed="0.5"
  >
    <gfy-spotlight color="#c556c6" intensity="2.68" distance="14.47" angle="0.85" penumbra="0.45" decay="0.24" x="-4.47" y="2.4" z="0.53"></gfy-spotlight>
    <gfy-spotlight color="#30ffe2" intensity="2.08" distance="8.73" angle="0.63" penumbra="1" decay="0" x="-1.6" y="-5.33" z="3.67"></gfy-spotlight>
    <gfy-spotlight color="#ffffff" intensity="2.03" distance="0" angle="0.35" penumbra="1" decay="1" x="6.13" y="2.67" z="2.13"></gfy-spotlight>
    <gfy-spotlight color="#ff4cfa" intensity="1.25" distance="7" angle="0.82" penumbra="1" decay="0.5" x="0.53" y="2.4" z="3.4"></gfy-spotlight>
    <gfy-spotlight color="#ffffff" intensity="0.63" distance="7" angle="0.79" penumbra="1" decay="0.5" x="-3" y="-3" z="6.2"></gfy-spotlight>
  </gfy-blob>
  <div class="my-data">
    <img src="img/maxart.jpg" alt="My face" class="my-face" />
    <h2>Massimo Artizzu</h2>
    <p>
      Web Architect<br />
      @<a href="https://gellify.com" class="gellify">Gellify</a>
    </p>
  </div>
  <div class="my-info">
    <h4>
      <a href="https://github.com/MaxArt2501"><img src="img/github.svg" alt="GitHub logo" /></a> /
      <a href="https://mastodon.social/MaxArt2501"><img src="img/mastodon.svg" alt="Mastodon logo" /></a> /
      <a href="https://bsky.app/profile/MaxArt2501.bsky.social"><img src="img/bluesky.svg" alt="BlueSky logo" /></a> /
      <a href="https://dev.to/MaxArt2501"><img src="img/dev-to.svg" alt="dev.to logo" /></a>
      @MaxArt2501
    </h4>
  </div>
</p-slide>
<p-slide class="center">
  <h3>You can find these slides at</h3>
  <img src="img/qr-slides-dev-fest.svg" alt="QR Code for the presentation's link" style="height: 7em; margin-bottom: 1em" />
  <a href="https://maxart2501.github.io/js-is-an-oddball-talk/dev-fest/">maxart2501.github.io/js-is-an-oddball-talk/dev-fest/</a>
</p-slide><!--/slide:cover-devfest-->
<!--slide:jsfck-devfest--><p-slide>
  <pre class="big self-center"><code class="language-js">'Ba' + +'üçå' + 'a'</code></pre>
  <p-fragment class="self-center">
    <pre class="big"><code class="language-js">[] == ![]</code></pre>
  </p-fragment>
  <p-notes>
    So, I want to talk about weird things in JS. But not <em>this</em> kind of weird things... Or <em>this</em> language oddity, no. I want to talk about unusual syntax, forgotten
    APIs, unexpected behaviors that could have an impact in our everyday job as JS developers.
  </p-notes>
</p-slide>
<p-slide class="stack">
  <pre style="font-size: 25.3%; white-space: normal; word-break: break-all; margin: 0">
[][(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(+(!+[]+!+[]+!+[]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]])+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]])()([][(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]]+((!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[+[]]+[!+[]+!+[]+!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[+!+[]])[(![]+[])[!+[]+!+[]+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]]((!![]+[])[+[]])[([][(!![]+[])[!+[]+!+[]+!+[]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]](([][(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(![]+[+[]])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+!+[]+[+[]]]+![]+(![]+[+[]])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+!+[]+[+[]]])()[([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[+[]])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+!+[]+[+[]]])+[])[+!+[]])+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]])())</pre
  >
  <p-fragment style="place-self: center">
    <code class="language-js" style="background: var(--slide-bg); padding: 0.5em">console.log('DevFest')</code>
  </p-fragment>
  <p-notes>And then again, it doesn't even mean a way to write code like <em>this</em> (which, by the way, is a very verbose way of writing)</p-notes>
</p-slide><!--/slide:jsfck-devfest-->
<!--slide:sorting--><p-slide>
  <pre class="big self-center"><code class="language-js">[2, 13, 1].sort() // [1, 13, 2] üôÑ</code></pre>
  <p-fragment class="self-center">
    <pre class="big"><code class="language-js">[2, 13, 1].sort((a, b) => a - b) // [1, 2, 13] üéâ</code></pre>
  </p-fragment>
  <p-notes>And also forget about annoyances like sorting a list of number, because we have a well known solution, don't we?</p-notes>
</p-slide>
<p-slide>
  <pre
    class="big self-center"
  ><code class="language-js">['File 2', 'File 13', 'File 1'].sort(</code><p-fragment class="collapsed"><code class="language-js">...?...</code></p-fragment>)&nbsp;&nbsp;&nbsp;

  </pre>
  <p-notes>But hear me out, what if we want to sort an array of strings that <em>contain</em> numbers? So that, of course, 'File 13' comes <em>after</em> 'File 2'?</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">['File 2', 'File 13', 'File 1'].sort((a, b) => {
  return a.slice(5) - b.slice(5);
});</code></pre>
  <p-notes>This could also be easily done with a specific solution. But what if things get more complicated?</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">[
  'File 2',
  'SS1 Aurelia',
  'SS16 Adriatica',
  'fiLE 15',
  'SS4 Salaria',
  'Die Hard 2: Die Harder',
  'Die Hard'
]</code><p-fragment><code class="language-js">.sort((a, b) => üò≠);</code></p-fragment></pre>
  <p-notes>Take <em>this</em> list, for example. There's no unique pattern. How can we deal with that?</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js input">['File 2', ...].sort((a, b) =></code><p-fragment><code class="language-js">
  a.localeCompare(b, undefined, { numeric: true })
</code></p-fragment><code class="language-js">);</code>
<p-notes>Believe it or not, this could be done with a <em>single line of JS</em>: this one!</p-notes>
<p-fragment class="self-center"><code class="language-js output">['Die Hard',   'Die Hard 2: Die Harder',
  'File 2',      'fiLE 15',
  'SS1 Aurelia', 'SS4 Salaria', 'SS16 Adriatica']</code></p-fragment></pre>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js input">[{ name: 'Venus', population: 0 },
   { name: 'Earth', population: 8e9 },
   { name: 'Mars',  population: 0 }].sort(</code><p-fragment><code class="language-js">
  (a, b) => a.name.localeCompare(b.name)
</code></p-fragment><code class="language-js">);</code>
<p-fragment class="self-center"><code class="language-js output">[{ name: 'Earth', population: 8e9 },
   { name: 'Mars',  population: 0 },
   { name: 'Venus', population: 0 }]</code></p-fragment></pre>
   <p-notes>You may have used <code>localeCompare</code> for this purpose: sorting an array of objects using one of their string properties.</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">a.localeCompare(b, locale, options)</code></pre>
  <p-fragment class="self-center">
    <div>
      <h3 class="center">==</h3>
    </div>
    <pre class="big"><code class="language-js">const collator = new Intl.Collator(locale, options);
collator.compare(a, b);</code></pre>
  </p-fragment>
  <p-fragment class="self-center">
    <span class="browser chrome">24</span>
    <span class="browser firefox">29</span>
    <span class="browser safari">10</span>
  </p-fragment>
  <p-notes>
    <p>
      But not everyone knows that <code>localeCompare</code> can take up to 3 arguments. The second is the locale string identifier, and the third is
      a set of options, which are the same of another less known API: <code>Collator</code>. And actually, <code>localeCompare</code> has been
      specified as equivalent to do this: so internally, it creates a <code>Collator</code> instance and use its <code>compare</code> method.
    </p>
    <p>It's been like that for a while now, as you can see.</p>
    <p>But is this code good for our job? Can we welcome these techniques in our codebases?</p>
  </p-notes>
</p-slide>
<p-slide>
  <h3 class="center">Introducing</h3>
  <div class="self-center bold" grid="2" style="font-size: 200%">
    <p-fragment grid style="grid-template-columns: subgrid" class="colspan-2"><span class="center">W</span><span>elcome</span></p-fragment>
    <p-fragment grid style="grid-template-columns: subgrid" class="colspan-2"><span class="center">T</span><span>echnology</span></p-fragment>
    <p-fragment grid style="grid-template-columns: subgrid" class="colspan-2"><span class="center">F</span><span>actor</span></p-fragment>
  </div>
  <p-fragment class="the-circle" aria-label="Marker circle around the initials W T F" style="top: 25%; width: 3em; left: 23.5%; height: 9em"></p-fragment>
  <p-notes>So I'm going to introduce a estimate factor that you can use to know if you should use something or not. It is the...</p-notes>
</p-slide>
<p-slide>
  <h3 class="center">Should I use <em>that</em>?</h3>
  <p-fragment class="self-center">
    <code style="font-size: 200%">
      ü§î
      <p-fragment>* wtf</p-fragment>
    </code>
  </p-fragment>
  <p-notes>So, for the question "should I use that?", you take your personal evaluation and multiply it by the wtf value. It's simple as that</p-notes>
</p-slide>
<p-slide class="row justify-evenly align-center">
  <code class="language-js">let sum = a + b;</code>
  <p-fragment class="self-center" wtf-level="10"></p-fragment>
  <p-notes>For example, what about the plus operator? Yes, of course, you should absolutely use it! It's well known, it behaves as expected, so let's give it a wtf level of 10</p-notes>
</p-slide>
<p-slide class="row justify-evenly align-center">
  <code class="language-js">[][(![]+[])...</code>
  <p-fragment class="self-center" wtf-level="1"></p-fragment>
  <p-notes>
    But writing code in pluses, parentheses and brackets? It's a big no-no, so it's a 1. Never zero, because there always is a reason for that.
    After all, we <em>know</em> about writing code like that, don't we?
  </p-notes>
</p-slide>
<p-slide class="row justify-evenly align-center">
  <pre class="big"><code class="language-js">a.localeCompare(b, locale, opts)</code></pre>
  <p-fragment class="self-center" wtf-level="8"></p-fragment>
  <p-notes>So, <code>localeCompare</code> huh? I'd give it a 8, just because your team has probably to learn about it. But otherwise, go for it!</p-notes>
</p-slide>
<p-slide>
  <pre class="big"><code class="language-js">const collator = new Intl.Collator(locale, options);
hugeList.sort(collator.compare)</code><p-fragment><code class="language-js">.reverse(); // üîΩ</code></p-fragment></pre>
  <p-notes>
    By the way, a <code>Collator</code> instance is better if you have to sort large lists. The only problem is that it sorts only in the ascending
    order, so if we want the other direction we need to - you guessed it - use <code>reverse</code>. And if in all of this, you're triggered by the
    use of array-mutating methods like <code>sort</code> and <code>reverse</code>, I have good news for you.
  </p-notes>
</p-slide><!--/slide:sorting-->
<!--slide:arrays--><p-slide>
  <pre class="big self-center"><code class="language-js">    array.sort()  &#x27f6;  array.toSorted()

 array.reverse()  &#x27f6;  array.toReversed()

  array.splice()  &#x27f6;  array.toSpliced()

array[index] = x  &#x27f6;  array.with(index, x)
</code></pre>
  <p-fragment class="self-center">
    <span class="browser chrome">110</span>
    <span class="browser firefox">115</span>
    <span class="browser safari">16</span>
  </p-fragment>
  <p-notes>Because recently non-mutating alternative methods have been introduced. So here's a migration table.</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">array.length = n</code><p-fragment>  &#x27f6;  <code class="language-js">array.slice(0, n)</code></p-fragment>

   <p-fragment><code class="language-js">array.fill(0)</code></p-fragment><p-fragment>  &#x27f6;  <code class="language-js">array.toFilled(0)</code></p-fragment><p-fragment class="big-x" style="width: 4em; left: 71%; top: 32%"></p-fragment>
                      <p-fragment><code class="language-js">array.map(() => 0)</code></p-fragment>

</pre>
  <p-notes>What's left out? Well, we have a way to cut an array short, so to say. But actually we had that already, because it's <code>slice</code></p-notes>
  <p-notes>What's <em>actually</em> left out - and I have no idea why - is <code>fill</code>: there's no <code>toFilled</code> method, so we still have to rely on <code>map</code></p-notes>
</p-slide>
<p-slide class="row justify-evenly align-center">
  <pre class="huge"><code class="language-js">array.toSorted()
array.toReversed()
array.toSpliced()
array.with(index, x)</code></pre>
  <p-fragment class="self-center" wtf-level="8"></p-fragment>
  <p-notes>Why not a higher value? Let me explain</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js input">Array(3)</code>
<p-fragment><code class="language-js output">[empty &times; 3]</code></p-fragment>

<p-fragment><code class="language-js input">Array(3).toReversed()</code></p-fragment>
<p-fragment><code class="language-js output">[undefined, undefined, undefined]</code></p-fragment></pre>
  <p-notes>
    When you create an array like that, you get&hellip; 3 empty slots. But if you apply a non-mutating method, you get 3 undefined values. What's happening?
  </p-notes>
</p-slide>
<p-slide class="center">
  <h3><code>null</code></h3>
  <h3><code>undefined</code></h3>
  <h3><p-fragment class="collapsed"><code>empty</code>&nbsp;‚ÅâÔ∏è</p-fragment></h3>
  <p-notes>So in JS we have <code>null</code>, we have <code>undefined</code>&hellip; and now we have <code>empty</code>? What's that?</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">Array(3).forEach(console.log)</code>
<p-fragment><code class="language-js">// ¬Ø\_(„ÉÑ)_/¬Ø</code></p-fragment>

<p-fragment><code class="language-js">Array(2 ** 32 - 1)
// ‚ö°</code></p-fragment></pre>
  <p-notes>
    <code>empty</code> is the reason why when you create an array like that, and iterate over its content, you get a whole bunch of nothing. But also,
    if you create a huge array with 4 bln items, it does it in the blink of an eye.
  </p-notes>
  <p-notes>
    Browsers be like: "Ah! You thought I'd give you 32 GB of memory!? We don't <i>have</i> 32 GB of memory, and even if we had, no way I'm allocating them for <i>you</i>! If
    anything, I'll get them for <i>myself!</i>"
  </p-notes>
  <p-notes>
    Fact is, an array in JS are <em>not</em> a series of allocated memory portions: they're <em>hash maps</em>. A <em>sparse</em> array is a map with
    some of its indexes missing - empty slots. Non-mutating methods fill those with <code>undefined</code> so&hellip; watch out!
  </p-notes>
</p-slide><!--/slide:arrays-->
<!--slide:spread--><p-slide>
  <pre class="big self-center"><code class="language-js input">Object.entries(null)</code>
<p-fragment><code class="language-error output">Uncaught TypeError: Cannot convert
  undefined or null to object</code></p-fragment>

<p-fragment><code class="language-js input">typeof null</code>
<code class="language-js output">'object'</code></p-fragment></pre>
  <p-notes>Speaking of <code>null</code>, what happens if we get its&hellip; entries?</p-notes>
  <p-notes>We get an error! Fair enough, even though&hellip;</p-notes>
  <p-notes>Yeah, we know&hellip; It's a mistake. An annoying one.</p-notes>
</p-slide>
<p-slide>
  <pre
    class="big self-center"
  ><code class="language-js">if (typeof item === 'object'</code><p-fragment class="collapsed"><code class="language-js"> && item !== null</code></p-fragment><code class="language-js">) {</code>
  <p-fragment>üò´</p-fragment>
<code class="language-js">}</code></pre>
  <p-notes>Because every time I have to check if an object exists, I also have to check if it's not <code>null</code></p-notes>
  <p-notes>How happy would I be if I could replace it with something more useful, like&hellip;</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">if (typeof item === 'REALobject') {</code>
  <p-fragment>ü§©</p-fragment><p-fragment class="the-stroke" style="width: 28ch; top: .5em; left: calc(.667em + 4ch)"></p-fragment>
<code class="language-js">}</code></pre>
  <p-notes>Sadly, nothing like that exists. But what can we actually <em>do</em> with <code>null</code>?</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">const obj = null;</code>
<p-fragment><code class="language-js input">const result = { foo: 42, ...obj };</code></p-fragment><p-fragment class="highlight"
style="top: 1lh; left: 28ch; width: 6ch"></p-fragment>
<p-fragment><code class="language-js output">{ foo: 42 }</code></p-fragment>
  <p-notes>What if we spread it onto another object? What do we get? Not an error, but a copy of the object, without additional properties</p-notes>
</pre>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">result = { foo: 42, ...undefined };</code>

<p-fragment><code class="language-js">result = { foo: 42, ...x => x    };</code></p-fragment>

<p-fragment><code class="language-js">result = { foo: 42, ...false     };</code></p-fragment>

<p-fragment><code class="language-js">result = { foo: 42, ...42        };</code></p-fragment>

<p-fragment><code class="language-js">result = { foo: 42, ...''        };</code></p-fragment><p-fragment class="highlight"
style="top: 0; left: 23ch; width: 9ch; height: 9lh"></p-fragment></pre>
  <p-notes>
    And the same applies to other kind of values, like <code>undefined</code>, functions, booleans, numbers and the empty string.
    None of them throws, or adds properties.
  </p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-ts">let item: Item | null</code><p-fragment index="1" class="collapsed"><code class="language-js"> = null</code></p-fragment>;

<p-fragment><code class="language-ts">const payload = { action: 'add', ...item };</code></p-fragment><p-fragment index="2" class="code-popover" style="top: 2lh;left: -4ch;--popover-cursor-shift: 40ch"><div data-ts-error="2698">Spread types may only be created from object types.</div>
<code class="language-typescript">let item: null</code></p-fragment><p-fragment index="1" class="squiggle" style="top: 2lh;left: 33ch">...item</p-fragment></pre>
  <p-fragment class="self-center" index="2">
    <pre class="big"><code class="language-js">const payload = Object.assign({ action: 'add' }, item);</code></pre>
  </p-fragment>
  <p-notes>
    And even TypeScript doesn't mind, so we don't have to check if the object actually exist before spreading it.
    Unless TS infers that it's <em>actually</em> <code>null</code>. In that case, it complains.
    But we can always use <code>Object.assign</code>: no problems here! And it get better.
  </p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-ts">const item: Item = { ... };
const hasItem: boolean = shouldHaveItem(item);</code>

<p-fragment><code class="language-ts">const payload = {
  action: 'add',
  ...(hasItem ? item : {})</code><p-fragment class="the-stroke" aria-label="A strike through the text '...(hasItem ? item : {})' in the code"
    style="top: calc(.5em + 5lh);left: calc(.667em + 2ch);width: 24ch;"
></p-fragment>
  <p-fragment><code class="language-js">...hasItem && item</code></p-fragment>
};</p-fragment><p-fragment
  class="highlight" aria-label="A highlighting around '...hasItem && item' in the code" style="top: 6lh; left: 2ch; width: 18ch"></p-fragment></pre>
  <p-notes>
    Suppose we have an item, and we add it to our payload depending on a flag. Instead of the usual ternary, we can use what's called "short circuiting"
    and write it like that. Remember that booleans, like <code>false</code>, don't add properties? That's perfect!
  </p-notes>
</p-slide>
<p-slide class="row justify-evenly align-center">
  <pre class="big"><code class="language-js">const payload = {
  action: 'add',
  ...hasItem && item
};</code></pre>
  <p-fragment wtf-level="7"></p-fragment>
  <p-notes>
    Why only 7? Because, to be fair, it's not a very good example of readability. If you know "short circuiting", you know what I'm talking about
    even though the React community pretty much got used to that.
  </p-notes>
</p-slide><!--/slide:spread-->
<!--slide:create--><p-slide>
  <pre
    class="big self-center"
  ><code class="language-js">const person = new Person()</code><p-fragment class="the-stroke" aria-label="A strike through the text '= new Person()' in the code"
    style="top: calc(.5em + 0lh);left: calc(.667em + 13ch);width: 14ch;"
></p-fragment><p-fragment><code class="language-js">
             = Object.create(anotherPerson);</code></p-fragment></pre>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">function Person(name) {
  this.name = name;
}
Person.prototype = {
  greet() {
    console.log("Hi, I'm " + this.name);
  }
}</code></pre>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">function createPerson(name) {
  return Object.create({
    greet() {
      console.log("Hi, I'm " + this.name);
    }
  }, {
    name: { value: name }
  });
}</code></pre>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">const genericPerson = {
  greet() { ... }
};

const person = Object.create(genericPerson)</code><p-fragment class="the-stroke" aria-label="A strike through the text 'Object.create(genericPerson)' in the code"
    style="top: calc(.5em + 4lh);left: calc(.667em + 15ch);width: 28ch;"
></p-fragment><p-fragment><code class="language-js">
  {
    __proto__: genericPerson,
    name: 'Sam'
  };</code></p-fragment><p-fragment class="highlight" aria-label="A highlighting around '__proto__' in the code" style="top: 6lh; left: 4ch; width: 9ch"></p-fragment></pre>
</p-slide>
<p-slide class="stack">
  <pre class="big self-center"><code class="language-js">class Person {
  constructor(name) { this.name = name; }
  greet() { ... }
}</code><p-fragment><code class="language-js">
const person = {
  __proto__: Person.prototype,
  name: 'Sam'
};</code></p-fragment><p-fragment><code class="language-js">
person instanceof Person // true</code></p-fragment></pre>
  <p-fragment style="place-self: center; rotate: 10deg; margin-bottom: 2.5em">
    <code class="language-js" style="padding: 0.5em; background: var(--slide-bg); border: 0.1em solid">const person = new Person('sam');</code>
  </p-fragment>
</p-slide>
<p-slide class="row align-center justify-evenly">
  <pre><code class="language-js">// Tab 1
class AuthToken {
  constructor(authData) {
    // Side effects here...
  }
}</code><p-fragment><code class="language-js">
let authToken =
  new AuthToken({ credentials });</code></p-fragment><p-fragment><code class="language-js">
channel.postMessage(authToken);</code></p-fragment></pre>
  <p-fragment>
    <pre><code class="language-js">// Tab 2
channel.addEventListener('message',
  ({ data }) => {
    authToken = {
      __proto__: AuthToken.prototype,
      ...data
    };
  }
);</code></pre>
  </p-fragment>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">const userData = {
  __proto__: </code><p-fragment class="collapsed"><code class="language-js">null</code></p-fragment><code class="language-js">,
  name: 'Alice Bob'
};</code><p-fragment class="highlight" aria-label="A highlighting around '__proto__' in the code" style="top: 1lh; left: 2ch; width: 16ch"></p-fragment><p-fragment><code class="language-js">
userData.toString       // undefined
userData.hasOwnProperty // undefined</code><p-notes>Why should we have something like that?</p-notes></p-fragment></pre>
</p-slide>
<p-slide>
  <pre
    class="big self-center"
  ><code class="language-txt">https://my.site.com/app?foo=bar</code><p-fragment class="collapsed">&<code class="language-txt" style="color: #f44">__proto__.role=admin</code></p-fragment></pre>
  <p-fragment class="self-center"
    ><p-notes>If the user has no defined role (for example, because it's not logged in)</p-notes>
    <pre class="big"><code class="language-js">user.role // undefined</code>
<p-fragment><code class="language-js">const query = parseQueryString(location.search);</code><p-notes>Imagine a custom-made qeury string parsing function</p-notes></p-fragment>
<p-fragment><code class="language-js">user.role // 'admin' üò±</code><p-notes>Even if <code>user</code> has nothing to do with <code>query</code>!</p-notes></p-fragment></pre>
  </p-fragment>
</p-slide>
<p-slide>
  <p-notes>Similar things could happen for JSONs</p-notes>
  <pre class="big self-center"><code class="language-js">{ "__proto__": { "role": "admin" } }</code>

<p-fragment><code class="language-js">const data = JSON.parse(raw);</code></p-fragment>
<p-fragment><code class="language-js">// { __proto__: { role: 'admin' } }</code><p-notes>
  Now <em>this</em> is fine, but if you use this object for something apparently safe&hellip;
</p-notes></p-fragment>

<p-fragment><code class="language-js">const allData = Object.assign(
  { duration: 750 },
  data
);</code><p-notes>Whoops! But please note that using object spreading would have worked</p-notes></p-fragment></pre>
</p-slide>
<p-slide>
  <pre class="big no-clip"><code class="language-js">const person = Object.create(Person.prototype);
person.name = 'Sam';</code>

<p-fragment><code class="language-js">const person = {
  __proto__: Person.prototype,
  name: 'Sam'
};</code><p-notes>But also this method is too weird for you</p-notes></p-fragment>

<p-fragment><code class="language-js">const person = { name: 'Sam' };
Object.setPrototypeOf(person, Person.prototype);</code><p-notes>You can always use this one</p-notes></p-fragment><p-fragment
  class="highlight" aria-label="A highlighting around 'Object.setPrototypeOf' in the code" style="top: 9lh; left: 0ch; width: 21ch"></p-fragment></pre>
</p-slide>
<p-slide class="row justify-evenly align-center">
  <pre class="big"><code class="language-js">const person =
  Object.create(protoPerson);
person.name = 'Sam';</code></pre>
  <p-fragment wtf-level="6"></p-fragment>
  <p-notes>I guess it's official API, but it was conceinved in a weird time for JavaScript, when we had no <code>class</code></p-notes>
</p-slide>
<p-slide class="row justify-evenly align-center">
  <pre class="big"><code class="language-js">const person = {
  __proto__: protoPerson,
  name: 'Sam'
};</code></pre>
  <p-fragment wtf-level="5"></p-fragment>
  <p-notes>It's cooler but it's too weird to have a specially named property for this kind of thing</p-notes>
</p-slide>
<p-slide class="row justify-evenly align-center">
  <pre class="big"><code class="language-js">const person = { name: 'Sam' };
Object.setPrototypeOf(
  person,
  protoPerson
);</code></pre>
  <p-fragment wtf-level="9"></p-fragment>
</p-slide><!--/slide:create-->
<!--slide:static--><p-slide>
  <pre
    class="big self-center"
  ><code class="language-js">class Oddball</code><p-fragment class="collapsed"><code class="language-js"> extends null</code></p-fragment><code class="language-js"> {}</code></pre>

  <pre class="big self-center language-js"><p-fragment><code class="language-js input">new Oddball</code></p-fragment>
<p-fragment><code class="language-error output">Uncaught TypeError: Super constructor
  null of Oddball is not a constructor</code></p-fragment></pre>
  <p-notes>
    <p>But let's talk about <code>null</code> again. What if we use it as a superclass? What happens?</p>
    <p>Well, JS doesn't complain so far. But when we create an object of that class, then&hellip;</p>
  </p-notes>
  <p-notes>
    <p>Why whould you allow me to do that in the first place?! Just to use it for static properties and methods? Way to make Java developers happy, I guess!</p>
  </p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center no-clip"><code class="language-js">class Oddball extends null {</code><p-fragment class="vertical-collapsed"><code
    class="language-js">  static lang = 'JavaScript';
</code></p-fragment><p-fragment class="vertical-collapsed"><code
  class="language-js">  static getVersion() {
    return `ES${new Date().getFullYear()}`;
  }
</code></p-fragment><p-fragment class="vertical-collapsed"><code
  class="language-js">  static {
    this.lang = 'ECMAScript';
  }
</code></p-fragment>}<p-fragment class="highlight" style="width: 27ch; top: 5lh; left: 2ch; height: 3lh; color: red"></p-fragment></pre>
  <p-notes>Wait a minute, what's this?</p-notes>
</p-slide>
<p-slide>
  <h3 class="center no-margins">Static class initialization blocks</h3>
  <pre class="big self-center"><code class="language-js">class JavaScript {
  static {
    this.version = `ES${new Date().getFullYear()}`;
  }
}</code>

<p-fragment><code class="language-js input">JavaScript.version</code></p-fragment>
<p-fragment><code class="language-js output">'ES2025'</code></p-fragment></pre>
  <script>
    document.currentScript.parentElement.querySelector('.output').innerHTML = `'ES${new Date().getFullYear()}'`;
  </script>
  <p-notes>A piece of code that gets executed when the class is defined. So as you might expect, &hellip;</p-notes>
  <p-notes>Wait, this is pretty much&hellip; not interesting. Because it can be easily rewritten as&hellip;</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">class JavaScript {}

JavaScript.version =
  `ES${new Date().getFullYear()}`;</code></pre>
  <p-notes>
    <p>
      Actually, most of the examples you'll find online about static initialization blocks are like this. You may say "wow, this is cool!", but actually you'd use an unfamiliar
      syntax to accomplish something you already know how to do. So what's the point?
    </p>
    <p>
      If we want to really understand why we should use SIBs, we need a case where it takes advantage of the fact that's defined
      <em>inside a class</em>, and thus has access to a wider scope. Let's see an example.
    </p>
  </p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-ts">class Safe {</code><p-fragment class="vertical-collapsed"><code class="language-ts">  #secret = Math.random();
</code></p-fragment><p-fragment class="vertical-collapsed" index="1"><code class="language-ts">  get secret() {
    return this.#secret;
  }</code>
</p-fragment>}
</pre>
  <p-notes>
    Suppose we want to read the secret from an instance of <code>Safe</code>. We could expose a public method, but that would defy the purpose of private fields. Instead, we don't
    want consumers to have access to the secrect like we do.
  </p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><p-fragment class="vertical-collapsed" index="1"><code
    class="language-ts">let readSecret: (safe: Safe) => number;
</code></p-fragment><code class="language-ts">class Safe {
  #secret = Math.random();
</code><p-fragment class="vertical-collapsed" index="1"><code class="language-ts">  static {
    readSecret = (safe) => safe.#secret;
  }</code>
</p-fragment>}
<p-fragment class="vertical-collapsed" index="1"><code class="language-js input">readSecret(new Safe)</code>
<code class="language-js output">0.8331317890625574</code></p-fragment></pre>
  <p-notes>
    So, we want a function that we're going to read the private secret from a class instance. But we won't expose it to the outside world. And how are we going to do that? By using
    static initialization blocks, which <em>can</em> access to private fields. Sneaky, sneaky!
  </p-notes>
  <p-notes> And speaking of objects&hellip; </p-notes>
</p-slide>
<p-slide>
  <pre class="self-center no-clip" style="font-size: 450%; padding: 0"><code class="language-js">if (true)</code></pre>
</p-slide>
<p-slide class="row justify-evenly align-center">
  <pre class="big"><code class="language-js">class Whatever {
  static {
    console.log('Static!');
  }
}</code></pre>
  <p-fragment wtf-level="7"></p-fragment>
  <p-notes>I'd give it 7, because this syntax isn't common. And I don't think it'll ever become common, because its use cases are quite limited</p-notes>
  <p-notes>But since we're talking about objects&hellip;</p-notes>
</p-slide><!--/slide:static-->
<!--slide:json--><p-slide>
  <h3 class="center"><span class="JavaScript"></span> <p-fragment>Object Notation</p-fragment></h3>
  <p-fragment class="self-center center">
    <h1>‚ù§Ô∏è</h1>
    <h3 class="JavaScript"></h3>
  </p-fragment>
  <p-fragment class="big-x" style="width: 8em; top: 28%; left: calc(50% - 4em)"></p-fragment>
  <p-notes>JSON, you know. The most common object notation in JS-based projects, that thankfully replaced XML a while ago. It loves JS&hellip; <em>NOT</em>.</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js input">JSON.stringify({
  void: undefined,
  func() {},
  fn: () => {},
  symbol: Symbol(),
  [Symbol('foo')]: 'symbol'
})</code>
<p-fragment><code class="language-js output">'{}' // üôÑ</code></p-fragment></pre>
  <p-notes>It's not because when you try to serialize this kind of object you get basically nothing. That's why you shouldn't use&hellip;</p-notes>
</p-slide>
<p-slide>
  <pre
    class="big self-center"
  ><p-fragment class="the-stroke" aria-label="A strike through the JSON.parse+stringify code" style="width: 46ch"></p-fragment><code class="language-js">const copy = JSON.parse(JSON.stringify(item));</code></pre>
  <p-fragment class="self-center">
    <pre class="big"><code class="language-js">const copy = structuredClone(item);</code></pre>
  </p-fragment>
  <p-fragment class="self-center">
    <span class="browser chrome">98</span>
    <span class="browser firefox">94</span>
    <span class="browser safari">15.4</span>
  </p-fragment>
  <p-notes>It is better, as it preserves undefined, although it doesn't copy symbol properties, and throws if it meets function or symbol values</p-notes>
</p-slide>
<p-slide class="row justify-evenly align-center">
  <pre class="big"><code class="language-js">structuredClone(item);</code></pre>
  <p-fragment wtf-level="8"></p-fragment>
  <p-notes>I'd say 9, but <code>structuredClone</code> is actually <em>slower!</em></p-notes>
</p-slide>
<p-slide>
  <p-notes>So, let's say I want to produce a JSON like that.</p-notes>
  <pre class="big self-center"><code class="language-js">{ "bigMcHuge": 12345678901234567890 }</code></pre>
  <p-notes>
    Point is, JSONs can have arbitrarily large numbers. It's an interchange format, so it doesn't care about language limitations, not even JavaScript's. But JavaScript has
    arbitrarily large integers now, doesn't it? They're the BigInts.
  </p-notes>
  <pre class="big self-center language-js"><p-fragment><code class="language-js">const bigMcHuge = 12345678901234567890n;</code></p-fragment>

<p-fragment><code class="language-js input">JSON.stringify({ bigMcHuge })</code></p-fragment>
<p-fragment><code class="language-error output">Uncaught TypeError: Do not know how to
  serialize a BigInt</code></p-fragment></pre>
  <p-notes>And apparently JS doesn't know how to stringify a <em>number</em>, even though BigInts have the <code>toString</code> method. What gives?</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">BigInt.prototype.toJSON = function() {
  return this.toString();
};</code></pre>
  <p-notes>Let's try to fix that. As some of you may know, a <code>toJSON</code> method on an object gets called when we do <code>JSON.stringify</code> of that value</p-notes>
  <p-fragment>
    <h1 class="center">üò±</h1>
  </p-fragment>
  <p-notes>And I guess some of you might be horrified by this solution! After all&hellip;</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center">

  <code class="language-js">  array.flatten()</code><p-fragment class="big-x" style="width: 4em; left: 21%; top: 11%"></p-fragment><p-fragment>  &#x27f6;  <code class="language-js">array.flat()</code></p-fragment>

  <p-fragment><code class="language-js">array.contains(x)</code></p-fragment><p-fragment class="big-x" style="width: 4em; left: 18%; top: 38%"></p-fragment><p-fragment>  &#x27f6;  <code class="language-js">array.includes(x)</code></p-fragment>

  <p-fragment><code class="language-js">array.groupBy(fn)</code></p-fragment><p-fragment class="big-x" style="width: 4em; left: 18%; top: 63%"></p-fragment><p-fragment>  &#x27f6;  <code class="language-js">Object.groupBy(array, fn)</code></p-fragment>

</pre>
  <p-notes>That's the reason we we have&hellip;</p-notes>
  <p-notes>I'm still bitter about the last one. But in this specific case, it's all good, because&hellip;</p-notes>
</p-slide>
<p-slide>
  <blockquote>&hellip; one of the few cases where patching built-in objects is not explicitly discouraged</blockquote>
  <cite>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#use_within_json">MDN</a>
  </cite>
</p-slide>
<p-slide class="row justify-evenly align-center">
  <pre class="big"><code class="language-js">BigInt.prototype.toJSON = ...</code></pre>
  <p-fragment wtf-level="8"></p-fragment>
  <p-notes>So let's give this technique a wtf level of 8, and move on.</p-notes>
</p-slide>
<p-slide>
  <p-fragment index="1" style="position: absolute; top: 10%; left: 40%">
    <span class="browser chrome">85</span>
    <span class="browser firefox">79</span>
    <span class="browser safari">14</span>
    <div class="the-arrow" style="top: 75%; left: 33%; width: 0.8em; rotate: 10deg"></div>
  </p-fragment>
  <p-notes>
    Let's define this <code>toJSON</code> method, then. Maybe using this operator: the "nullish coalescing assignment operator"&hellip;
    That's a mouthful! But it's well supported and makes our code kind of future-proof.
  </p-notes>
  <pre
    class="big self-center"
  ><code class="language-js">BigInt.prototype.toJSON </code><p-fragment class="collapsed"><code class="language-js">??</code></p-fragment>= <code class="language-js">function() {
  return this.toString();
};</code><p-fragment class="highlight" style="width: 3ch; top: 0; left: 24ch"></p-fragment>

<p-fragment index="1"><code class="language-js input">JSON.stringify({ bigMcHuge })</code></p-fragment>
<p-fragment index="1"><code class="language-js output">'{"bigMcHuge":"12345678901234567890"}'</code></p-fragment></pre>
  <p-notes>Then we call <code>JSON.stringify</code>&hellip; and we're done! Or <em>are</em> we?</p-notes>
  <p-fragment index="1"
  ><img src="img/pointer.webp" alt="A pointing hand to the opening quotes of the number" class="pointing-start" /><img
    src="img/pointer.webp"
    alt="A pointing hand to the closing quotes of the number"
    class="pointing-end"
    /></p-fragment>
  <p-notes>
    <p>What are <em>those</em>?! They're double quotes! We don't want them!</p>
    <p>It's because the method doesn't return a <em>serialized</em> string: it's meant to return a serializable <em>value</em>! That gets serialized after that</p>
  </p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">BigInt.prototype.toJSON ??= function() {</code>
  <p-fragment><code class="language-js">return JSON.rawJSON(this.toString());</code></p-fragment><p-fragment
  class="highlight" aria-label="A highlighting around the JSON.rawJSON function name" style="top: 1lh; left: 9ch; width: 12ch"></p-fragment>
<code class="language-js">};</code>

<p-fragment><code class="language-js input">JSON.stringify({ bigMcHuge })</code></p-fragment>
<p-fragment><code class="language-js output">'{"bigMcHuge":12345678901234567890}'</code></p-fragment></pre>
  <p-fragment style="position: absolute; top: 50%; left: 80%; font-size: 200%">üéâ</p-fragment>
  <p-fragment class="self-center">
    <span class="browser chrome">114</span>
    <span class="browser firefox">135</span>
    <span class="browser safari">-</span>
  </p-fragment>
  <p-notes>But we <em>do</em> have a solution! It's called&hellip;</p-notes>
  <p-notes>It returns a special object that's used by <code>JSON.stringify</code> alone.</p-notes>
  <p-notes>The only problem is that it's still not supported by Safari. There's a polyfill, though.</p-notes>
  <p-notes>
    <code>JSON.rawJSON</code> returns a frozen object with no prototype, and a single constant string property named <code>rawJSON</code>, whose value is the function
    argument and must be a formally correct JSON <i>primitive</i> value. It cannot even be converted to a string, but has an internal flag that allows us to use it with
    <code>JSON.stringify</code> alone.
  </p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">const raw = '{ "bigMcHuge": 12345678901234567890 }';</code>

<p-fragment><code class="language-js input">JSON.parse(raw)</code></p-fragment>
<p-fragment><code class="language-js output">{ bigMcHuge: 12345678901234567000 }</code></p-fragment><p-fragment
class="highlight" style="top: 3lh; left: 32ch; width: 3ch; color: red"></p-fragment><p-fragment
class="highlight" style="top: 0; left: 45ch; width: 3ch; color: red"></p-fragment></pre>
  <p-notes>
    What about the opposite? A JSON with a large number, we want to transform it into a JS object. If we use <code>JSON.parse</code> alone, we lose precision
  </p-notes>
  <p-notes>Some may say: "I know! I'll use a reviver!" - Except, no you don't.</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">JSON.parse(raw, (key, value) => {</code>
  <p-fragment><code class="language-js">// value already lost precision :(</code></p-fragment>
<code class="language-js">});</code></pre>
  <p-notes>Because at this point, <code>value</code> has already been converted to a number. What then?</p-notes>
</p-slide>
<p-slide>
  <pre
    class="big self-center"
  ><code class="language-js">JSON.parse(raw, (key, value</code><p-fragment class="collapsed"><code class="language-js">, context</code></p-fragment><code class="language-js">) => {   </code>
  <p-fragment index="1"><code class="language-js">return BigInt(context.source);</code></p-fragment>
<code class="language-js">});</code></pre>
  <p-notes>Well, now the reviver accepts a <em>third</em> argument, the context. Which is <em>that</em> object. And you may guess how we can use it</p-notes>
  <p-notes>But again, Safari still doesn't support it, you have to provide a polyfill</p-notes>
  <p-fragment>
    <pre class="big" style="position: absolute; top: 10%; left: 30%"><code class="language-js">{ source: '12345678901234567890' }</code></pre>
    <div class="the-arrow" style="top: 24%; left: 63%; scale: -1 1; width: 1.2em"></div>
  </p-fragment>
  <p-fragment class="self-center" style="position: absolute; bottom: 25%" index="1">
    <span class="browser chrome">114</span>
    <span class="browser firefox">135</span>
    <span class="browser safari">-</span>
  </p-fragment>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">JSON.parse(raw, (key, value, { source }) => {
  return isBigInt(source) ? BigInt(source) : value;
});</code><p-fragment class="highlight" aria-label="A marker circle around 'isBigInt' function name"
  style="top: 1lh;width: 8ch;left: 9ch"></p-fragment>

<p-fragment><code class="language-js">const isBigInt = numstr => !/\D/.test(numstr) &&</code></p-fragment>
  <p-fragment><code class="language-js">numstr.localeCompare(
    '9007199254740991', undefined, { numeric: true }
  ) > 0;</code></p-fragment></pre>
  <p-notes>Of course we can't convert every value to a bigint, so we need to discriminate</p-notes>
  <p-notes> There must be something that tells us when a numeric string is greater than another&hellip; Golly, it's our good friend <code>localeCompare</code>! </p-notes>
  <p-notes>I love when a language comes together like that. But it doesn't mean there aren't any problems! Even with <em>classic</em> syntax like&hellip;</p-notes>
</p-slide><!--/slide:json-->
<!--slide:pattern--><p-slide>
  <h1 class="center"><code>switch</code></h1>
  <p-notes>switch is kinda awkward</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">switch (count) {
  case 0:
    text = 'no result';</code><p-fragment class="vertical-collapsed"><code class="language-js">    break;</code></p-fragment>  <code class="language-js">case 1:</code>
    ...<p-fragment class="vertical-collapsed"><code class="language-js">  default:
    text = '';</code></p-fragment><code class="language-js">}</code></pre>
  <p-notes>
    At the first glance this looks fine, but then you notice you must give it a <code>break</code>, and then a <code>default</code> case.
    It's verbose, it's boring. That's why so many use&hellip;
  </p-notes>
</p-slide>
<p-slide>
  <pre
    class="big self-center"
  ><code class="language-js">if (count === 0</code><p-fragment class="collapsed"><code class="language-js"> && !text</code></p-fragment><code class="language-js">) {
  text = 'no result';
} else if (count === 1) {&nbsp;&nbsp;
  ...
} else {
  text = '';
}</code></pre>
  <p-notes>A bunch of ifs instead. Which are even more versatile when specificying the conditions.</p-notes>
  <p-notes>But what if I told you we can do <em>way</em> better with <code>switch</code> too?</p-notes>
</p-slide>
<p-slide>
  <pre
    class="big self-center"
  ><code class="language-js">switch (</code><p-fragment class="collapsed"><code class="language-js">true</code></p-fragment>) {<p-fragment class="vertical-collapsed"><code
    class="language-js">  case count === 0 && !text:
    text = 'no result';
    break;
  ...
</code></p-fragment>}<p-fragment class="highlight" aria-label="A marker circle around 'true'"
style="top: 0;width: 4ch;left: 8ch"></p-fragment><p-fragment class="highlight" aria-label="A marker circle around the first condition"
style="top: 1lh;width: 20ch;left: 7ch"></p-fragment></pre>
  <p-notes>So we take a <code>switch</code>&hellip; we put <code>true</code> as the comparison value! Not a variable, but a value.</p-notes>
  <p-notes>
    <p>What happens then? It executes the first case whose condition is strictly <code>true</code>.</p>
    <p>
      We still have to use <code>break</code> but now can express whatever we want, like an <code>if</code>, and even better if you're
      a strict-typing aficionado because, again, the comparison is strict, not loose. It's like pattern matching for JS!
    </p>
  </p-notes>
</p-slide>
<p-slide>
  <pre class="self-center"><code class="language-ts">const getContent = async (children: ReactNode) => {
  switch (true) {
    case children == null:
      return '';
    case typeof children !== 'object':
      return String(children);
    case typeof children.then === 'function':
      return getContent(await children);
    case Symbol.iterator in children:
      return Array.from(children, getContent).join('');
    default:
      return '';
  }
};</code><p-fragment
  class="highlight" style="width: 16ch; left: 9ch; top: 2lh; color: red"></p-fragment><p-fragment
  class="highlight" style="width: 28ch; left: 9ch; top: 4lh; color: red"></p-fragment><p-fragment
  class="highlight" style="width: 35ch; left: 9ch; top: 6lh"></p-fragment><p-fragment
  class="highlight" style="width: 27ch; left: 9ch; top: 8lh; color: gray"></p-fragment></pre>
</p-slide>
<p-slide>
  <pre class="self-center no-clip" style="font-size: 330%; padding: 0"><code class="language-js">switch (true)</code></pre>
</p-slide>
<p-slide class="row justify-evenly align-center">
  <pre class="big"><code class="language-js">switch (true) {...}</code></pre>
  <p-fragment wtf-level="4"></p-fragment>
  <p-notes>Ok, jokes aside, let's give it a wtf value. It's 4. Because, to be honest, it's so unexpected that you feel mentally violated by this!</p-notes>
  <p-notes>So my suggestion is: don't use it in production. Maybe in your personal projects.</p-notes>
  <p-notes>But we cannot talk about odd stuff in JS without considering the first, examplary environment where JS was born and has grown.</p-notes>
</p-slide><!--/slide:pattern-->
<!--slide:dom--><p-slide>
  <h1 class="center">DOM<p-fragment class="vertical-collapsed uppercase">P√©rignon<br>üçæ</p-fragment></h1>
  <p-notes>So full of weird stuff that you might argue that the name comes from their favorite drink, but it's sadly mostly historic</p-notes>
  <p-notes>Technically they're not JS API, but Web API, but they show how JS has been used for them</p-notes>
</p-slide>
<p-slide>
  <pre class="huge self-center"><p-fragment class="collapsed"><code class="language-js input">typeof </code></p-fragment><code class="language-js">document.all</code><p-fragment
    class="vertical-collapsed"><code class="language-js output">'undefined'</code></p-fragment></pre>
  <p-notes>No, we won't talk about this. Which apparently doesn't even exist.</p-notes>
  <p-notes>You shouldn't use this, anyway. Now you could say, "How am I supposed to get the list of all elements, then?"</p-notes>
</p-slide>
<p-slide>
  <pre class="huge self-center"><code class="language-js">document.querySelectorAll('*')</code></pre>
</p-slide>
<p-slide>
  <ul class="center">
    <li>Text nodes?</li>
    <li><p-fragment>Comments?</p-fragment></li>
    <li>
      <p-fragment><code class="language-html">&lt;select></code>s with no value?</p-fragment>
    </li>
    <li><p-fragment>Elements wider than 80px?</p-fragment></li>
  </ul>
</p-slide>
<p-slide>
  <h1 class="center">‚òùÔ∏è</h1>
</p-slide>
<p-slide>
  <h1 class="center">‚úåÔ∏è</h1>
</p-slide>
<p-slide>
  <pre class="huge self-center"><code class="language-js">TreeWalker</code></pre>
  <pre class="huge self-center" style="margin-top: -0.5em"><code class="language-js">NodeIterator</code></pre>
  <p-notes>They've been available for a while. A <em>long</em> while actually, as they're supported by IE 9!</p-notes>
  <p-fragment class="self-center">
    <span class="browser chrome">1</span>
    <span class="browser firefox">4</span>
    <span class="browser safari">3</span>
    <p-fragment class="collapsed"><span class="browser ie">9</span></p-fragment>
  </p-fragment>
  <p-notes>I must tell you, they're one of the <em>most adorably</em> Java-fashioned APIs that you could ever meet!</p-notes>
  <p-notes>How do they work? Basically the same, with <code>TreeWalker</code> that could do some more stuff, but it matters little.</p-notes>
</p-slide>
<p-slide>
  <pre class="self-center no-clip"><code class="language-html">&lt;section>
  &lt;h3>
    Latest news
  &lt;/h3>
  &lt;article>
    &lt;h4>
      JavaScript considered harmful
    &lt;/h4>
    &lt;p>
      To your sanity, to be precise. &hellip;
    &lt;/p>
    &hellip;
  &lt;/article>
&lt;/section></code><p-fragment class="the-pointer"></p-fragment><p-fragment></p-fragment></pre>
  <p-notes>
    We start from a root node, we decide what we're looking for - for example, text nodes - and it does what you expect it do to: pointing to every text
    node inside the root node.
  </p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center"><code class="language-js">const walker = </code><p-fragment class="vertical-collapsed"><code class="language-js">  document.createTreeWalker(
    sectionEl,</code><p-fragment class="vertical-collapsed"><code class="language-js"
>    NodeFilter.SHOW_TEXT</code><p-fragment class="collapsed"><code class="language-js"> | NodeFilter.SHOW_COMMENT</code></p-fragment>,</p-fragment><p-fragment class="vertical-collapsed"><code class="language-js"
>    (node) => node.data.includes('JavaScript')</code></p-fragment><p-fragment class="vertical-collapsed"><code class="language-js"
>      ? NodeFilter.FILTER_ACCEPT
      : NodeFilter.FILTER_REJECT</code></p-fragment>  );</p-fragment></pre>
  <p-notes>But we don't use <code>new</code> like a sane person would do: we use a factory function. You can smell the Java from there!</p-notes>
  <p-notes>We provide a root node, we tell it what kind of node we're interested in&hellip; with an enum and bit mask, but Java!</p-notes>
  <p-notes>And then we can provide an additional filtering function&hellip; which should return an enum value again! Can you smell the roasting beans?</p-notes>
</p-slide>
<p-slide>
  <pre class="big self-center no-clip"><code class="language-js">const walker = document.createTreeWalker(
  sectionEl,
  NodeFilter.SHOW_TEXT | NodeFilter.SHOW_COMMENT,
  {
    acceptNode(node) {
      return node.data.includes('JavaScript')
        ? NodeFilter.FILTER_ACCEPT
        : NodeFilter.FILTER_REJECT;
    }
  }
);</code><p-fragment class="highlight"
style="top: 3lh; left: 2ch; width: 43ch; height: 7lh"></p-fragment></pre>
  <p-notes>&hellip; or you can wrap it in an object with a <code>acceptNode</code> method, because, at this point, why not, we can go full Java 7 on this</p-notes>
</p-slide>
<p-slide>
  <pre class="huge self-center no-clip"><code class="language-js">walker.nextNode()</code><p-fragment class="vertical-collapsed"><code class="language-js"
>      .previousNode()</code></p-fragment><p-fragment class="vertical-collapsed"><code class="language-js"
>      .parentNode()
      .firstChild()
      .lastChild()
      .nextSibling()
      .previousSibling()</code></p-fragment><p-fragment class="highlight" style="width: 18ch; left: 6ch; top: 2lh; height: 5lh; color: red"></p-fragment></pre>
  <p-notes>In a <code>NodeIterator</code> you only have the first two methods</p-notes>
</p-slide>
<p-slide class="row justify-evenly align-center">
  <pre class="big"><code class="language-js">TreeWalker
NodeIterator</code></pre>
  <p-fragment wtf-level="7"></p-fragment>
  <p-notes>Only 7 because well, they're awkward to use in 2025. Maybe wrap them in generator functions. And then, I bet you won't have to look for comment nodes often</p-notes>
  <p-notes>That's for <em>getting</em> the nodes. What about <em>creating</em> them? We have <code>createElement</code> and the others, but&hellip;</p-notes>
</p-slide>
<p-slide>
  <pre class="self-center big"><code class="language-js">element.insertAdjacentElement(position, element);

element.insertAdjacentText(position, text);

element.insertAdjacentHTML(position, html);</code></pre>
  <p-notes>We also have <em>these</em>. And for a <em>very</em> long while! Since IE 6!</p-notes>
  <p-notes>Who's been born in 2001 or later here? These methods are older than <em>you</em>!</p-notes>
  <p-notes>That's kind of embarassing, TBH. But maybe we can still find them a purpose?</p-notes>
  <p-fragment class="self-center">
    <span class="browser chrome">1</span>
    <span class="browser firefox">8</span>
    <span class="browser safari">4</span>
    <p-fragment class="collapsed"><span class="browser ie">6</span></p-fragment>
  </p-fragment>
</p-slide>
<p-slide>
  <pre class="self-center big"><code class="language-js clip" style="width: 22ch">element.insertAdjacent()</code><code class="language-js">*(position, stuff)</code></pre>
  <p-fragment class="self-center">
    <pre class="flex align-center big">
      <code class="language-js">position = </code>
      <code class="language-js">'beforebegin'
'afterbegin'
'beforeend'
'afterend'</code>
    </pre>
  </p-fragment>
</p-slide>
<p-slide>
  <pre class="self-center big no-clip"><code class="language-html">&lt;main>
  &lt;article>
    &lt;header>...&lt;/header>
    ...
    &lt;footer>...&lt;/footer>
  &lt;/article>
  ...
&lt;/main></code><p-fragment class="highlight"
style="top: 1lh; left: 2ch; width: 9ch"></p-fragment><p-fragment
class="line-pointer" style="top: .4em; left: calc(.667em + 2ch); text-indent: 12ch"><code class="language-js">'beforebegin'</code></p-fragment><p-fragment
class="line-pointer left" style="top: calc(.5em + 1lh); left: calc(.667em - 12ch); width: 17ch"><code class="language-js">'afterbegin'</code></p-fragment><p-fragment
class="line-pointer top left" style="top: calc(.5em + 5lh); left: calc(.667em - 12ch); width: 17ch"><code class="language-js">'beforeend'</code></p-fragment><p-fragment
class="line-pointer top" style="top: calc(.6em + 6lh); left: calc(.667em + 2ch); text-indent: 15ch"><code class="language-js">'afterend'</code></p-fragment></pre>
  <p-notes>Let's say we execute them on this article element.</p-notes>
  <p-notes>We can visualize where the "stuff" will be put.</p-notes>
  <p-notes>But actually we have something better today!</p-notes>
</p-slide>
<p-slide>
  <pre class="self-center big"><code class="language-js">element.append(nodeOrString</code><p-fragment class="collapsed"><code class="language-js">, ...</code></p-fragment><code class="language-js">)</code><p-fragment class="vertical-collapsed"><code class="language-js">element.prepend(nodeOrString, ...)
element.before(nodeOrString, ...)
element.after(nodeOrString, ...)</code></p-fragment></pre>
  <p-fragment class="self-center">
    <span class="browser chrome">54</span>
    <span class="browser firefox">49</span>
    <span class="browser safari">10</span>
  </p-fragment>
  <p-notes>It can takes DOM nodes, or a string, which is conveniently translated into a text node. And more than one, it can take multiple!</p-notes>
  <p-notes>And there are all the others, equivalent to the other positions too. And widely available!</p-notes>
</p-slide>
<p-slide class="row justify-evenly align-center">
  <pre class="big"><code class="language-js">el.append()
el.prepend()
el.before()
el.after()</code></pre>
  <p-fragment wtf-level="9"></p-fragment>
</p-slide>
<p-slide>
  <pre class="self-center big"><p-fragment class="the-stroke" aria-label="A strike through the first line" style="width: 49ch"></p-fragment><code class="language-js">element.insertAdjacentElement(position, element);</code>

   <p-fragment class="the-stroke" aria-label="A strike through the second line" style="width: 43ch"></p-fragment><code class="language-js">element.insertAdjacentText(position, text);

   element.insertAdjacentHTML(position, html);</code><p-fragment class="highlight"
style="top: 4lh; left: 3ch; width: 43ch"></p-fragment></pre>
  <p-notes>So what should we do about these ones? Are they still useful? The first two, clearly not. But what about the third?</p-notes>
</p-slide>
<p-slide>
  <pre class="self-center big"><p-fragment class="the-stroke" aria-label="A strike through the line" style="width: 46ch"></p-fragment><code class="language-js">element.innerHTML += '&lt;div>Some HTML...&lt;/div>';</code></pre>
  <p-fragment class="self-center">
    <pre class="big"><code class="language-js">element.insertAdjacentHTML(
  'beforeend',
  '&lt;div>Some HTML...&lt;/div>'
);</code></pre>
  </p-fragment>
  <p-notes>It seems we can do the same with this, but&hellip; Everything not in the markup would be <em>lost</em>:</p-notes>
  <p-notes>
    <ul>
      <li>event listeners;</li>
      <li>internal states;</li>
      <li>all references.</li>
    </ul>
  </p-notes>
</p-slide>
<p-slide class="row justify-evenly align-center">
  <pre class="big"><code class="language-js">el.insertAdjacentHTML()</code></pre>
  <p-fragment wtf-level="3"></p-fragment>
  <p-notes>Why so low? To be fair, normally we don't have to deal with DOM manipulation like that anymore. We don't pass around raw HTML,
    we prefer to use libraries to generate and inject nodes around. But then!</p-notes>
</p-slide>
<p-slide class="row justify-evenly align-center">
  <div class="center">
    <pre class="big"><code class="language-js">el.insertAdjacentHTML()</code></pre>
    for debugging
  </div>
  <p-fragment wtf-level="7"></p-fragment>
  <p-notes>I've actually used that for console experiment and debugging purposes. And it's been quite handy! So maybe consider it?</p-notes>
</p-slide><!--/slide:dom-->
<!--slide:the-end-devfest--><p-slide>
  <h1 class="center"><span>That's all, folks!</span><br />üëã</h1>
  <p-notes>
    I would like to leave you with this thought: the JS ecosystem is so vast, so full of history and literature, that there's always something to learn. And learning takes us to
    new perspectives, and rediscover ways of solving our problems. And if in the meanwhile we face some quirkyness, well&hellip; I think it's part of the fun! Thank you!
  </p-notes>
</p-slide>
<p-slide>
  <h3 class="center final-link">
    <a href="https://maxart2501.github.io/js-is-an-oddball-talk/dev-fest/"> maxart2501.github.io/js-is-an-oddball-talk/dev-fest/ </a>
    <img src="img/qr-slides-dev-fest.svg" alt="QR Code for the presentation's link" />
  </h3>
</p-slide><!--/slide:the-end-devfest-->
    </p-deck>
    <div role="progressbar" class="presentation-progress" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" title="Presentation progress"></div>
    <div role="toolbar" class="presentation-toolbar">
      <button type="button" class="toggle-mode" title="Toggle speaker mode" aria-label="Toggle speaker mode (Alt-M)">
        <svg viewBox="0 0 1 1">
          <path stroke-width="0.1" stroke="currentColor" fill="none" d="M.05 .5h.6v-.45h-.6v.9h.6v-.45M.75 .05h.25M.75 .2h.25M.75 .35h.25" />
        </svg>
      </button>
      <button type="button" class="fullscreen" title="Toggle fullscreen mode" aria-label="Toggle fullscreen mode">
        <svg viewBox="0 0 1 1">
          <g stroke="currentColor" fill="none" stroke-width="0.1">
            <path d="M.05 .3v-.25h.25M.7 .05h.25v.25M.95 .7v.25h-.25M.3 .95h-.25v-.25" />
            <path d="M.05 .3h.25v-.25M.7 .05v.25h.25M.95 .7h-.25v.25M.3 .95v-.25h-.25" />
          </g>
        </svg>
      </button>
    </div>
    <nav class="presentation-nav">
      <button type="button" class="previous" title="Go backward" aria-label="Go backward"></button>
      <button type="button" class="next" title="Go forward" aria-label="Go forward"></button>
    </nav>
    <script type="module" src="js/main.js"></script>
    <script type="module" src="js/presentation.js"></script>
    <script defer type="module" src="js/blob.js"></script>
    <script defer src="vendor/prismjs/prism.js"></script>
    <script defer src="vendor/prismjs/components/prism-javadoclike.js"></script>
    <script defer src="vendor/prismjs/components/prism-typescript.js"></script>
    <script defer src="vendor/prismjs/components/prism-jsdoc.js"></script>
  </body>
</html>
